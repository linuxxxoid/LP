# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Вельтман Л.Я.


## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |        5       |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я получила много полезных навыков. Во-первых, для выполнения первого задания нужно было написать парсер, обрабатывающий текстовые данные (в частности, данные в формате GEDCOM). Это определенно важное умение, которое можно применить в любом проекте, так как обработка текстовых данных встречает повсеместно. Во-вторых, реализовала поиск двоюродного брата, было интересно протестировать свое дерево на данном предикате. В-третьих, закрепила навыки, полученные в 3 лабораторной работе, где нужно было применить поиск в пространстве состояний. В курсовом проекте это понадобилось для построения цепочки родства. В-четвертых, создание естественно-языкового интерфейса посредством предикатов, описанных в Прологе. Думаю, что реализация такого задания на императивном языке программирования заняла бы больше строк, времени и нервов. Ну и наконец, написание реферата помогло мне навсегда зафиксировать в своей памяти все существующие поколения компьютеров. Также было очень интересно изучать историю создания компьютеров 5-го поколения, хоть и не очень удачную. 
В итоге, я улучшила свои познания в логическом языке программирования Prolog. Возможно, если передо мной встанет задача, то сначала я взвешу все за и против, отмечу преимущества и недостатки языков программирования для решения моего задания, и если окажется, что для его решения лучше всего подойдет логическая парадигма, то я точно сделаю адекватный выбор в пользу Пролога. 

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Я зарегистрировалась на сервисе MyHeritage.com, создала свое родословное дерево, в нем оказалось 56 человек. Затем я экспортировала дерево из этого сервиса в формате GEDCOM.

## Конвертация родословного дерева

Для решения данной задачи я решила использовать знакомый мне язык C++. Работа программы заключается в том, что построчно проходя по файлу, мы находим id человека, его имя и фамилию, пол. Добавляем эти данные в соответствующие поля вектора family структуры FamMember (id, name, sex). Далее находим следующую информацию: кто является мужем, женой, есть ли у них дети (которых мы добавляем в вектор children). Запоминаем id этих людей и с помощью функции FindIndex узнаем их индексы вектора family и выводим предикаты parents(Родитель, ребенок) в выходной файл. После прохождения всего файла, читая данные поля sex вектора family структуры FamMember, выводим предикат sex(Человек, male/female) в файл. 

## Предикат поиска родственника

Согласно варианту мне нужно реализовать предикат поиска двоюродных братьев (cousin). Для его реализации я написала предикат sibling (поиск братьев и сестер).

```prolog
sibling(Sibling, Person):-
parent(P, Person),
parent(P, Sibling),
Person \= Sibling.

cousin(Cousin, Person):-
parent(P1, Person),
parent(P2, Cousin),
sibling(P1, P2),
sex(Cousin, "male"),
Person \= Cousin.
```

Предикат sibling проверяет, есть ли общие родители у двух человек и имеет проверку, не один и тот же ли это человек.
```prolog
sibling(Person, Sibling):-
child(Person, P),
child(Sibling, P),
Person \= Sibling.
```    
Предикат cousin проверяет, кто является двоюродным братом для Person. Двоюродный брат - это ребенок мужского пола, у которого один из родителей является братом или сестрой для родителей человека под именем Person. Поэтому сначала ищем родителей для  Person и Cousin и затем проверяем родство между этими родителями. Если родство подтверждается, то уточняем пол персонажа Cousin, если это мужчина и Person и Cousin не один и тот же человек, то все верно.
```prolog
cousin(Cousin, Person):-
parent(P1, Person),
parent(P2, Cousin),
sibling(P1, P2),
sex(Cousin, "male"),
Person \= Cousin.
```
Результат работы:
```prolog
?- cousin(Cousin, "Ярослав Вельтман").
Cousin = "Глеб Вельтман"
Cousin = "Дмитрий Вельтман"
false.

?- cousin(Cousin, "Лина Вельтман").
false.
```

## Определение степени родства

Для поиска родства я использовала алгоритм поиска из 3 лабораторной работы: поиск с итеративным заглублением. Остановила свой выбор именно на нем, потому что он является модификацией двух поисков, позволяет исправить немало недостатков как поиска в глубину, так и поиска в ширину. Итерационным заглублением называется поиск в глубину, первая итерация которого ограничена 1 уровнем. Если цель не найдена, выполняется еще один шаг с предельной глубиной 2. В процессе поиска предельная глубина увеличивается на 1 на каждой итерации. На каждой итерации алгоритм выполняет поиск в глубину с учетом текущего предельного числа уровней. При этом при переходе от одной итерации к другой информация о пространстве состояний не сохраняется. Еще одним преимуществом этого поиска является то, что он был подробно разобран на одной из лекций .С помощью предиката check_link(связь, личность, личность) определяются прямые отношения между двумя людьми. Строится родственная цепочка через отца, мать, сестру, брата, сына, дочь, мужа, жену.
```prolog
check_link(Mother, Child, mother) :-
	parent(Mother, Child),
	sex(Mother, 'female').

check_link(Father, Child, father) :-
	parent(Father, Child),
	sex(Father, 'male').

check_link(Daughter, Parent, daughter) :-
	parent(Parent, Daughter),
	sex(Daughter, 'female').

check_link(Son, Parent, son) :-
	parent(Parent, Son),
	sex(Son, 'male').

check_link(Sister, Y, sister) :- 
	sibling(Y, Sister),
	sex(Sister, 'female').

check_link(Brother, Y, brother) :-
	sibling(Y, Brother),
	sex(Brother, 'male').

check_link(Wife, Husband, wife) :- 
	parent(Wife, Child),
	parent(Husband, Child),
	Husband \= Wife,
	sex(Wife, 'female').

check_link(Husband, Wife, husband) :- 
	parent(Wife, Child),
	parent(Husband, Child),
	Husband \= Wife,
	sex(Husband, 'male').
 ```
Результат работы:
```prolog
?- relative('Velizar Veltman','Lina Veltman', X).
X = [brother].

?- relative('Zoya Maslenkova','Natalya Utkina',X).
X = [mother, wife, son].

?- relative('Pavel Veltman','Victor Romanenko',X).
X = [father, husband, daughter].

?- relative('Gleb Veltman','Pavel Alishkin',X).
X = [son, brother, father, husband, daughter, sister, mother].

?- relative('Svetlana Lvova','Ulyana Biryukova', X).
X = [wife, brother, mother, wife, brother, mother].
```

## Естественно-языковый интерфейс

Реализован естественно-языковой интерфейс, позволяющий задавать вопросы относительно степеней родства и проверять истинность введенных высказываний о родственниках. Сначала проверяются введенные данные, корректность построения вопроса. В зависимости от типа вопроса ищется ответ. С помощью предиката nb_setval запоминается относительно какого человека (его имени) задается вопрос, чтобы при последующем возможном вопросе с использованием местоимения можно будет дать осмысленный ответ или проверить релевантность введенного вопроса относительно родства, вызвав предикат nb_getval, который вернет значение (имя человека) глобальной переменной, созданной при работе предиката nb_setval. В вопросах на определение количества родственников был написанн предикат fammber, который приводит множественное число к единственному. В зависимости от количества родственников будет выводится информация о родстве либо в множественном либо в единственном числе. ask_relative ищет всех запрашиваемых родственников заданного человека, а setof создает список из найденных уникальных имен. Далее получаем длину этого списка и печатаем результат в нужном порядке и числе.
При анализе предложения также проверяем корректность построения и разбиваем его по частям, оборачивая части вопроса в соответствующие структуры.
```prolog
?- ask([who, is, 'Lina Veltman', "'s", mother, ?]).
Tatyana Romanenko is Lina Veltman's mother
true.

?- ask([who, is, her, brother, ?]).
Velizar Veltman is Lina Veltman's brother
true.

?- ask([how, many, brothers, does, 'Zoya Maslenkova', have, ?]).
Zoya Maslenkova has 3 brothers
true.

?- ask([is, 'Anatoly Maslenkov', her, father, ?]).
true.

?- ask([how, many, sisters, does, she, have, ?]).
Zoya Maslenkova has 1 sister
true.

?- ask([is, 'Nina Kovaleva', 'Ivan Utkin', "'s", wife, ?]).
true.

?- ask([is, 'Yuri Utkin', his, son, ?]).
true.

?- ask([who, is, 'Gleb Veltman',"'s", son, ?]).
Lev Veltman is Gleb Veltman's son
true.

?- ask([who, is, his, wife, ?]).
Lira Bagirova is Gleb Veltman's wife
true.

?- ask([is, 'Ulyana Biryokova', 'Velizar Veltman', "'s", daughter, ?]).
false.

?- analysis([who, is, 'Elena Veltman', "'s", son, ?], X).
X = sentence(type_of_question(questionWord(who), auxiliaryVerb(is)), names(person('Elena Veltman', "'s")), relationship_(son), mark_of_question(?)) .

?- analysis([how, many, brothers, does, 'Pavel Veltman', have, ?], X).
X = sentence(type_of_question(questionWord(how), much_many(many)), relationship_(brothers), helpWord(does), names(person('Pavel Veltman')), haveHas(have), mark_of_question(?)) .

?- analysis([who, is, 'Velizar Veltman', "'s", sister, ?], X).
X = sentence(type_of_question(questionWord(who), auxiliaryVerb(is)), names(person('Velizar Veltman', "'s")), relationship_(sister), mark_of_question(?)) .

?- analysis([is, 'Zoya Maslenkova', 'Tatyana Romanenko', "'s", mother, ?], X).
X = sentence(type_of_question(auxiliaryVerb(is)), names(person('Zoya Maslenkova'), relative_('Tatyana Romanenko', "'s")), relationship_(mother), mark_of_question(?)) .
```
## Выводы

Данная лабораторная работа была ориентирована именно на использование логического языка программирования. Мне понравилась сама задумка данных заданий, так как мы работали с семейным древом, что, например, напрямую отражает идею поиска в Прологе.
Эта работа показывает реальную задачу, при решении которой лучше всего использовать логический язык программирования.

В итоге хотелось бы сказать, что данный курс был довольно сложным, так как тяжело было перестроиться на новую парадигму программирования. Синтаксис Пролога прост, его можно легко читать, но написание дается очень трудно. Главная ошибка программиста, что он хочет сразу представить как программа работает, а не прочитать, что программа описывает, это коснулось и меня. Однако впечатления, которые он оставил и опыт, мотивировали меня на изучение многих языков программирования, так как применение одного языка для различных задач является неправильным подходом, ведь многие труднореализуемые задачи для одного ЯП, будут описываться на другом языке в несколько простых строк!
