# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Вельтман Л.Я.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      4--      |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Все структурные объекты Пролога — это деревья. Списки не являются исключением из этого правила.
Список в прологе отличается от списков в императивных языках. Во-первых, обработка списков осуществляется при помощи рекурсии, разделяя список на голову и хвост, в то время как в императивных языках, чтобы обратиться к какому-то элементу списка, можно использовать итераторы. Во-вторых, элементы списка в Прологе могут быть любого типа, что совершенно противоречит императивным языкам, ведь в них в списке могут храниться только элементы одинакового типа. В конце концов, не во всех императивных языках программирования реализованы списки. Внешне списки Пролога немного напоминают массивы, если, например, рассматривать объявление статического массива в C/C++ Array[3] = {1,2,3} и списка в Прологе List = [1, 2, 3]. Но все же к элементам массива мы имеем произвольный доступ, чего не скажешь о списках.
Во всех других отношениях Пролог не отличается от традиционных языков программирования. Как и в случае программы написанной на любом другом языке, Пролог-программа предназначена для решения отдельной задачи.

## Задание 1.1: Предикат обработки списка

`remove_std(X, L1, L2)` - Удаление всех элементов списка по значению с помощью стандартных предикатов.

`remove_all(X, L1, L2])` - Удаление всех элементов списка по значению без использования стандартных предикатов.

Примеры использования:
```prolog
?- remove_std(24, [0, 0, 0, 3, 24, 23, 2, 3], Result).
Result = [0, 0, 0, 3].
?- remove_std(6, [6, 6, 6, 6, 6, 6], Result).
Result = [].
?- remove_std(90, [], Result).
false.

?- remove_all(5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Result).
Result = [1, 2, 3, 4].
?- remove_all(1, [1, 1, 1, 1, 1], Result).
Result = [].
?- remove_all(1, [], Result).
false.
```

Реализация:
```prolog
remove_std(X, L1, L2) :- append(L2, [X | _], L1).
```
С помощью стандартного предиката append можно удалить все элементов списка по значению! и сам элемент тоже. Для этого указываем исходный список в качестве получаемого после слияния в предикате append (3 аргумент). Список L2 и список, начинающийся с элемента X, должны быть равны списку L1 после слияния, поэтому при удачном исходе (элемент X был найден в исходном списке) список L2 будет содержать в себе все элементы списка L1 до элемента X (не включая), так как стоит на 1 месте в предикате append, тем самым предшествуя остальной части списка, содержащей X. Передаем L2 в качестве 3 аргумента в первоначальный предикат remove_std, что будет являться ответом на поставленную задачу. 
```
Предикат remove_std выполняет другую задачу (результат д.б. такой же как в предикате remove_all)

remove_all(X, [X | _], []) :- !.
remove_all(X, [H | T],[H | T1]) :- remove_all(X, T, T1).
```
Рекурсивно "обрезаем" исходный список, ищем голову списка, равную элементу X. Когда элемент был найден, делаем список пустым и с помощью отсечения закрепляем все решения предшествующие появлению его в предложении. При выходе из каждого рекурсивного шага, элементы, обрезаемые в исходном списке, возвращаются туда же, к тому же помещаются в начало результирующего списка.


## Задание 1.2: Предикат обработки числового списка
`remove_std(X, L1, L2)` - Слияние двух упорядоченных списков с помощью стандартных предикатов.

`remove_all(X, L1, L2])` - Слияние двух упорядоченных списков без использования стандартных предикатов.

Примеры использования:
```prolog
?- std_sort_lists_to_one([],[9,7,6,5], Result).
false.
?- std_sort_lists_to_one([],[], Result).
false.
?- std_sort_lists_to_one([1, 5, 3],[], Result).
false.
?- std_sort_lists_to_one([1, 5, 3],[66, 23, 11], Result).
Result = [1, 3, 5, 11, 23, 66].
?- std_sort_lists_to_one([9,0,1,4,5], [67,23,3,12], Result). 
Result = [0, 1, 4, 5, 9, 3, 12, 23, 67].

?- sort_lists_to_list([9, 0, 23, -1], [99, 12, 15], Result). 
Result = [-1, 0, 9, 23, 12, 15, 99].
?- sort_lists_to_list([], [9, 12, 15], Result). 
false.
?- sort_lists_to_list([7, 87], [], Result). 
false.
?- sort_lists_to_list([-7, -10], [12, 9, 9, 5], Result). 
Result = [-10, -7, 5, 9, 9, 12].
```
Реализация:
```prolog
std_sort_lists_to_one(_, [], []) :- !, fail.
std_sort_lists_to_one([], _, []) :- !, fail.
std_sort_lists_to_one(L1, L2, L3) :-
    msort(L1, T1),
    msort(L2, T2),
    append(T1, T2, L3).
```
На вход подается два списка, они сортируются с помощью стандартного предиката msort и сливаются в один список засчет предиката append. Если один из списков пуст, то завершение неудачей, так как нужно слить именно два упорядоченных списка.

```prolog
my_qsort([], []).
my_qsort([H | T], L) :-
    my_split(H, T, Small, Big),
    my_qsort(Small, SmallSort),
    my_qsort(Big, BigSort),
    my_append(SmallSort, [H | BigSort], L).

% Разделяем список на 2 списка: Small(числа < H) и Big(числа >= H)
my_split(_, [], [], []).
my_split(H, [H2 | R], [H2 | Small], Big) :-
    H2 < H,
    my_split(H, R, Small, Big).
my_split(H, [H2 | R], Small, [H2 | Big]) :-
    H2 >= H,
    my_split(H, R, Small, Big).
    
sort_lists_to_list(_, [], []) :- !, fail.
sort_lists_to_list([], _, []) :- !, fail.
sort_lists_to_list(L1, L2, L3) :-
    my_qsort(L1, T1),
    my_qsort(L2, T2),
    my_append(T1, T2, L3).

```
На вход подается два списка, они упорядочиваются при помощи быстрой сортировки и сливаются в один список реализованным мною предикатом my_append. Если один из списков пуст, то завершение неудачей, так как нужно слить именно два упорядоченных списка.

Разница предикатов, реализованных через стандартные, и без них д.б. в их реализациях, а не в названиях append, my_append.

Быстрая сортировка (предикат my_qsort) была реализована, соблюдая следующий алгоритм:
1. Удалить из списка голову H и разбить оставшийся список на два списка Small и Big следующим образом: все элементы большие чем H помещаются в Big и меньшие H - в Small.
2. Отсортировать список Small в SmallSort.
3. Отсортировать список Big в BigSort.
4. Соединить списки SmallSort H и BigSort.

## Задание 2: Реляционное представление данных

В настоящее время наиболее популярны реляционные базы данных, в которых данные представляются в виде совокупности таблиц. Термин «реляционный» означает, что теория основана на математическом понятии отношение (relation). Поэтому реляционное представление показывает отношения между объектами. Результат запроса к таким данным - это неименованное производное отношение, удовлетворяющее внутренней структуре программы. Модель таких данных определена заранее, является строго типизированной. Задача состоит в том, чтобы реализовать такую структуру, обеспечивающую правильность и полноту ответов. Достоинством реляционного представления является простота разработки, так как программа разбивается на отдельные компоненты, которые реализуются независимо друг от друга. Кроме того, устойчивость, гибкость, масштабируемость, производительность и совместимость предполагают доминирующее положение в сфере управления данными. К недостаткам можно отметить, что реляционные БД хорошо масштабируются только в том случае, если располагаются на единственном сервере. На сегодняшний день разнообразие приложений растет, они работают в условиях высокой нагрузки, поэтому их требования к масштабируемости  меняются и неумолимо возрастают. А когда ресурсы одного сервера закончатся, необходимо будет добавить больше машин и распределить нагрузку между ними. Если попробовать увеличить количество серверов не до нескольких штук, а до сотни или тысячи, сложность возрастет на порядок, и характеристики, которые делают реляционные БД такими привлекательными, стремительно снижают к нулю шансы использовать их в качестве платформы для больших распределенных систем.

Мой вариант представления данных можно охарактеризовать как списки групп и журнал успеваемости по предметам. Трудность такого представления состоит в том, что все факты об оценках находятся внутри предиката subject, который в свою очередь состоит из списка функторов. Как итог, когда нужно получить информацию об оценках, не всегда удобно обращаться со списками. Нет особого разделения оценок по группам, они находятся в общем списке. Для работы с реляционной базой данных в прологе обычно используют стандартные предикаты asseta, assertz, retractall, consult, save и другие, но в данная лабораторная работа не предполагает модификации исходных данных, поэтому использовать их нет необходимости. Преимуществом такого представления можно отметить легкий доступ к данным, содержащим отношения "предмет-оценка", соответственно отношения "группа-предмет" создавали некоторые трудности. Если бы информация о группе находилась в функторе grade, было бы намного удобнее реализовывать некоторые предикаты.
Из-за проблем с кодировками, мне пришлось изменить русские буквы на английские (Логическое программирование стало Logical programming), структура, порядок, число предикатов не были изменены или нарушены.
Для своего представления данных я выбрала 2 вариант.

1. Напечатать средний балл для каждого предмета.

`average_mark(Subject, Mark)` - cредний балл по предмету.

Примеры использования:
```prolog
?- average_mark('English language', Mark).
Mark = 4.
?- average_mark('Informatics', Mark).
Mark = 3.8214285714285716.
```
Реализация:
```prolog
% Сумма оценок по предмету
% (список оценок, сумма оценок)
sum_grades([], 0).
sum_grades([grade(_, N) | T], Sum) :-
    sum_grades(T, M),
    Sum is N + M,

% Средний балл по предмету
% (название предмета, средняя оценка)
average_mark(Subject, Mark) :-
    subject(Subject, Grade),
    sum_grades(Grade, Sum),
    length(Grade, Size),
    Mark is Sum / Size.
```
Получаем список всех оценок по предмету, затем подсчитываем сумму всех баллов по этому предмету, затем узнаем среднее арифметическое, то есть средний балл (сумму делим на количество оценок).

2. Для каждой группы, найти количество не сдавших студентов.

`count_fail_group(Group, Count)` - поиск числа несдавших студентов в заданной группе.

Примеры использования:
```prolog
?- count_fail_group(101, Count).
Count = 3.
?- count_fail_group(104, Count).
Count = 2.
```
Реализация:
```prolog
is_member(X, [X | _]).
is_member(X, [_ | T]) :-
    is_member(X, T).

% Список всех оценок по всем предметам
% (список предметов, список оценок)
all_marks([], _).
all_marks([H | T], Marks_list) :-
    subject(H , X),
    all_marks(T, New_list),
    append(X, New_list, Marks_list).

% Удаление повторяющихся оценок, 
% если в списке один и тот же студент 
% получил больше одной 2 по разным предметам,
% он должен считаться один раз
delete_all(_, [], []).
delete_all(X, [X | L], L1) :- delete_all(X, L, L1).
delete_all(X, [Y | L], [Y | L1]) :- 
    X \= Y,
    delete_all(X, L, L1).

deletion_same_marks([], []).
deletion_same_marks([H | T], [H | T1]) :-
    delete_all(H, T, T2),
    deletion_same_marks(T2, T1).

% Проверяем, сколько студентов, получивших 2, имеются в нужной группе
% (список всех оценок, список группы, количество несдавших студентов из группы)
checker([], _, 0).
checker([grade(X , Y) | T], Names, N) :- 
    Y < 3,
    is_member(X, Names),
    !,
    checker(T, Names, M),
    N is M + 1.
checker([_ | T], Names, N) :- checker(T, Names, N).

% Количество несдавших студентов в группе
% (номер группы, число несдавших)
count_fail_group(Group, Count):-
    group(Group, Names),
    findall(Sub, subject(Sub, _), Subject_list),
    all_marks(Subject_list, Marks_list),
    deletion_same_marks(Marks_list, New),
    checker(New, Names, Count).
```
Получаем список студентов нужной группы, список всех возможных предметов и все оценки по всем предметам, удаляем повторяющиеся оценки, чтобы, если один и тот же студент не сдал больше 1 предмета, не считать его дважды, проверяем сколько из несдавших студентов являются студентами заданной группы.

3. Найти количество не сдавших студентов для каждого из предметов.

`fail_stud_number(Subject, Count)` - поиск числа несдавших студентов для выбранного предмета.

Примеры использования:
```prolog
?- fail_stud_number('Logical programming', Count).
Count = 3.
?- fail_stud_number('Psychology', Count).
Count = 2.
```
Реализация:
```prolog
%(список оценок, количество несдавших)
count_fail_stud([], 0).
count_fail_stud([grade(_, Mark) | T], N) :-
    Mark < 3,
    !,
    count_fail_stud(T, C),
    N is C + 1.
count_fail_stud([_ | T], N) :- count_fail_stud(T, N).

%(название предмета, число студентов)
fail_stud_number(Subject, Count) :-
    subject(Subject, Info),
    count_fail_stud(Info, Count).
```
Получаем список оценок по выбранному предмету и считаем, сколько в этом списке содержится двоек.

## Выводы

Императивные языки основаны на фон неймановской модели вычислений компьютера. Решая задачу, императивный программист сначала должен создать модель в некоторой формальной системе, а затем переписать решение на императивный язык программирования. Пролог является декларативным языком программирования, то есть  в основе лежит человеческая логика. Программа на Прологе описывает не процедуру решения задачи, а логическую модель предметной области: факты относительно свойств этой области и отношений между этими свойствами, а также правила вывода новых свойств и отношений из уже заданных. Фактически Пролог представляет собой не столько язык для программирования, сколько язык для описания данных и логики их обработки. Такой логический подход к программированию создает и некоторые проблемы в распространении языка: основные понятия языка опытными программистами понимаются без труда, однако практическое претворение этого понимания в полезные программы вызывает затруднения. Это случилось и со мной, поначалу было сложно описать свои идеи в предикатах и было не всегда очевидно, в какой последовательности он будет работать. Но методом проб и ошибок, используя трассировку, наблюдая пошаговое выполнение предиката, стало намного понятнее, как и в каком порядке выполняются правила. Думаю, чтобы понять концепции логического программирования нужно больше практики. Данная лабораторная работа предоставила такую возможность. Как известно, Пролог широко применяется для решения задач искусственного интеллекта, для меня эта тема является интересной, поэтому изучение этого языка программирования - маленький шажок к приближению к разработке интеллектуальных компьютерных систем.
