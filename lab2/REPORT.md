#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Вельтман Л.Я.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      4        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Особенности Пролога и дескриптивной парадигмы программирования проявляются наиболее ярко при решении содержательных логических задач. Говоря про подходы к решению логических задач в Прологе, сразу же вспоминается работа Шерлока Холмса, так как задается некоторый набор фактов, которые надо увязать между собой, чтобы найти решение, таким же способом следовал и герой романа. Пролог решает такие задачи полным перебором. Существует 2 основных подхода к решению логических задач: метод порождения и проверок и метод ветвей и границ. Суть первого метода состоит в том, что некоторый предикат генерирует множество исходных данных, которые затем проверяются другими предикатами на предмет соответствия условию задачи. В случае неуспеха происходит возврат и рассмотрение следующего решения, в случае успеха полученное решение возвращается пользователю или используется дальше. В методе ветвей и границ значительные части возможных решений отсекаются на раннем этапе выполнения или вообще не генерируются. Очевидно, что программа, написанная с помощью второго метода, будет работать быстрее.
Пролог удобен для решения логических задач, потому что он дает возможность рассмотрения большого количества вариантов решения задачи и выбора из них подходящих. Механизм бэктрекинга при обнаружении неуспеха автоматически пересматривает решение и вытается продолжить выполнение программы при других значениях переменных.

## Задание

11. 6 человек назовем их А, Б, В, Г, Д и Е кандидаты посты председателя, заместителя председателя и секретаря правления общества любителей логических задач. Но определить состав этой тройки оказалось не так-то легко. Судите сами: А не хочет входить в состав руководства, если Д не будет председателем. Б не хочет входить в состав руководства, если ему придется быть старшим над В. Б не хочет работать вместе с Е ни при каких условиях. В не хочет работать, если в состав руководства войдут Д и Е вместе. В не будет работать, если Е будет председателем, или если Б будет секретарем. Г не будет работать с В или Д, если ему придется подчиняться тому или другому. Д не хочет быть заместителем председателя. Д не хочет быть секретарем, если в состав руководства войдет Г. Д не хочет работать вместе с А, если Е не войдет в состав руководства. Е согласен работать только в том случае, если председателем будет либо он, либо В. Как они решили эту проблему? .

## Принцип решения

Главный предикат solve. На вход подается список из трех аргументов, 1 - председатель, 2 - заместитель председателя, 3 - секретарь. Задача состоит в том, чтобы определить, личности людей(буквы), которые занимают эти должности. Этот список передается в предикат candidates, где есть список, состоящий из 6 человек L = ['A', 'B', 'V', 'G', 'D', 'E']. В этом предикате происходит перебор людей для составления тройки руководителей без повторений, благодаря отрицаниям not.
```prolog
candidates([X, Y, Z]) :-
	L = ['A', 'B', 'V', 'G', 'D', 'E'],
	is_member(X, L),
	is_member(Y, L),
	not(X = Y),
	is_member(Z, L),
	not(Y = Z),
	not(X = Z).
  ```
  Как только такая тройка нашлась, мы возвращаемся в основной предикат и происходит унификация этого списка со списком [Chairman, Deputy, Secretary], чтобы была возможность работать дальше, так как в списке List могут лежать различные элементы списка L, которые можно увидеть только используя трассировку. Первое условие задачи звучит так: "А не хочет входить в состав руководства, если Д не будет председателем."
```prolog
Chairman = 'D'; not(is_member('A', List)),
  ```
Перевести с Пролога - это можно так: либо Д - председатель(была использована унификация), либо А не член руководства, что полностью отражает логику заданного условия. Получается, что на первом условии отсекается большинство возможных решений, и мы возвращаемся в предикат candidates для поиска новой тройки потенциальных руководителей.
  
Предикат older определяет истинно ли то, что элемент X является главенствующим, то есть элемент Z находится у него в подчинении. Существуют 3 различных варианта, когда X - председатель, тогда Z может быть только заместителем или секретарем и X - заместитель, тогда Z только секретарь. При выполнении одного из условий возвращается true.
```prolog
older(X, Z, [X, Z, _]). 
older(X, Z, [X, _, Z]).
older(X, Z, [_, X, Z]).
```
Второе условие задачи: "Б не хочет входить в состав руководства, если ему придется быть старшим над В." представляется в Прологе так:
```prolog
not(older('B', 'V', List)); not(is_member('B', List)),
```
То есть, происходит проверка старшинства Б над В, если это истина, то not сделает эту истину ложью и придется искать новую тройку кандидатов, если же not вернет истину, то продолжаем проход по условиям.

Далее условия проверок идентичны, меняются лишь аргументы. Единственное, что осталось неосвещенным, так это предикат is_member, стандартный предикат поиска значения в списке, который завершается удачей, если элемент найден. Соответственно для продвижения по условиям главного предиката отрицание not должно возвращать истину после использования предиката is_member, а это значит одно:
```prolog
not(is_member('B', List))
```
такая конструкция говорит о том, что В не должен быть членом списка.
Реализация стандартного предиката member (is_member) ниже:
```prolog
is_member(X, [X | _]).
is_member(X, [_ | T]) :- is_member(X, T).
```

## Выводы

Результатом работы моей программы является единственное верное решение. Ни одно из условий задачи не было нарушено. Моя задача была достаточна проста с точки зрения написания дополнительных предикатов для различных проверок, так как пришлось лишь описать уже заданные условия задачи, вспомогательный, но очень важный стандартный предикат member(названный мной is_member), предикат older и предикат candidates.

Пролог удобен для решения подобных логических задач. Все, что требуется от программиста - это описать условия и задать некоторую логику, последовательность, и как следствие, будут отсекаться неподходящие варианты и находиться нужное решение. Это намного проще, чем решать такую задачу вручную, проверяя все возможные решения. Нельзя исключать вероятность, что на маленьких входных данных будет проще решить задачу самому, на бумаге. По моему мнению, эффективность решения задачи на Прологе будет проявляться именно на больших данных. Подобные задачи на Прологе решаются механически, ведь меняются лишь предикаты с условиями и генерация.
