#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Вельтман Л.Я.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Задача грамматического разбора и анализа естественных и искусственных языков является одной из самых распространенных задач, решаемых языками логического программирования. Это связано с простотой и естественностью реализации процесса переборов с возвратами, а также с удобством манипулирования символьной информацией.

Подходы обработки естественных языков:

Предварительный анализ - выделение абзацев, предложений, слов.

Морфологический анализ - установление форм слова и приписывание им морфологических признаков.

Синтаксический анализ - анализ строения предложения и так же выделяются зависимости между словами.

Семантический анализ - определение смысла слова.

Пролог обладает большими возможностями по сопоставлению объектов с эталонном, поэтому данный язык очень хорошо подходит для обработки текстов. На Прологе можно с успехом реализовать генераторы отчетов, текстовые редакторы и трансляторы языков. В интерпретаторе Пролога по умолчанию принята стратегия решения задач с обратным ходом решения. Т.е. решение начинается с запроса, которое разбивается на подцели правила, далее делится на еще более мелкие составные части и т.д. На ней же базируется и система нисходящего грамматического разбора. Поэтому реализация такого разбора на Прологе осуществляется достаточно прямолинейным способом.

## Задание

Вариант задания следут вычислять как ((N-1) mod 28) + 1, где N - номер по списку в группе.

1. Генеалогическое дерево задано фактами вида
parent(alexei,tolia).

parent(alexei,volodia). 

parent(tolia,tima).
...
Написать программу на Прологе, запросы к которой будут выглядеть следующим образом:
.................................................................................................................
#### Запросы:
?- answer([volodia, brat , toli, ‘?’],X).

?- answer([kto, tolin, brat, ‘?’],X).

?- answer([chei, brat, volodia, ‘?’],X).

Результаты: X=yes, X=volodia, X=tolia.

## Принцип решения

С помощью предиката check_link(личность, личность, связь) определяются прямые отношения между двумя людьми. Были написаны предикаты для основных возможных вопросов о родстве. Три из них для вопросов, заданных на русском языке (написание букв через английские) и остальная тройка вопросов, подчиняющиеся английской грамматике синтаксического построения предложений. Также реализованы предикаты на определение составляющих частей вопроса, что очень облегчает дальнейшую работу.
Используется встроенный предикат setof, который составляет список Res объектов X, удовлетворяющих условию предиката ask_relative, который производит поиск родственных связей через предикаты check_links и факты parent, sex. Причем список упорядочен и исключает повторения, если они есть.
```prolog
/* kto '<name>' relation ? */
answer(List, Res) :-
	List = [A, B, C, D],
	question_word(A), relatives(C),
    famber(C1, C), question_mark(D),
    setof(X, ask_relative(X, B, C1), Res).
```
Этот предикат выдает список родственников, если они есть, при неудаче выводит false. Полностью руссифицированный аналог мог быть:"Кто Маринин брат?", в моем случае вопрос будет звучать так:"Кто 'Марина' брат?".

Данный предикат реализует вопрос:"Чья сестра 'Марина'?". Полностью соответствует нормальной речи, что очень радует.
```prolog
/* chei/chya <relation> '<name>' ? */
answer(List, Res) :-
	List = [A, B, C, D],
	question_word(A), relatives(B),
    famber(B1, B), question_mark(D),
    setof(X, ask_relative(C, X, B1), Res).
```
"'Марина' сестра 'Володя'?" на английском языке такие вопросы звучат лучше, здесь опущено слово "это", его можно было добавить для удобства чтения.
```prolog
/* '<name>' relation '<name>' ? */
answer(List, Res) :-
	List = [A, B, C, D],
	relatives(B), famber(B1, B),
	question_mark(D), check_link(A, C, B1), !, Res = yes.
```
Данный предикат обрабатывает как множественность, так и единственность родственников. В ответе будет список членов семьи, удовлевтворяющих родственной связи.
```prolog
/* who is/are '<name>' 's <relation> ? */
answer(List, Res) :-
    List = [A, B, C, D, E, F],
    question_word(A), verb(B), apostrophe(D),
    check_relation(E), famber(E1, E),question_mark(F),
    setof(X, ask_relative(X, C, E1), Res).
```
```prolog
/* whose <relation> is '<name>' ? */
answer(List, Res) :-
    List = [A, B, C, D, E],
    question_word(A), check_relation(B), verb(C),
    question_mark(E),
    setof(X, ask_relative(D, X, B), Res).
```
"Whose son is Yuri Utkin?" выдаст список, состоящий из его родителей, в данном случае ответ будет выглядеть так:
```prolog
?- answer([whose, son, is, 'Yuri Utkin', ?], X).
X = ['Ivan Utkin', 'Nina Kovaleva'] 
```
"is Marina Lina's daughter?" - очень логичный вопрос, при удаче выдаст ответ "yes", иначе false.
```prolog
/* is '<name>' '<name>' 's <relation> ? */
answer(List, Res) :-
    List = [A, B, C, D, E, F], verb(A),
    apostrophe(D), check_relation(E),
    question_mark(F), check_link(B, C, E), !, Res = yes. 
```
## Результаты

```prolog
?- answer([chei, brat, 'Pavel Veltman', ?], X).
X = ['Alexandr Veltman', 'Oleg Veltman'] .

?- answer([kto, 'Zoya Maslenkova', bratya, ?], X).
X = ['Alexandr Maslenkov', 'Anatol Maslenkov', 'Vyacheslav Maslenkov'] .

?- answer(['Elena Veltman', sestra, 'Yaroslav Veltman', ?], X).
X = yes.

?- answer([who, is, 'Pavel Alishkin', "'s", son, ?], X).
X = ['Timur Alishkin'] 

?- answer([whose, mother, is, 'Nina Kovaleva', ?], X).
X = ['Natalya Utkina', 'Yuri Utkin'] 

?- answer([is, 'Oleg Veltman', 'Nikolay Veltman', "'s", son, ?], X).
X = yes.

?- answer([chya, sestra, 'Tatyana Romanenko', ?], X).
false.

?- answer([who, are, 'Galina Maslenkova', "'s", brothers, ?], X).
X = ['Alexandr Maslenkov', 'Anatol Maslenkov', 'Vyacheslav Maslenkov'] .

?- answer(['Lida Romanenko', zhena, 'Timur Alishkin', ?], X).
false.
```
## Выводы

К сожалению мне не удалось просклонять имена (принимать на вход одну форму и уже во время решения приводить слово к начальной форме и производить поиск в заданных фактах), хотелось применить предикат frontchar, но оказалось, что он работает только в Turbo Prolog, в то время как я использую SWI Prolog. Для меня единственным вариантом оставалось лишь не склонять имена, оставив их константными. В голову пришло еще одно решение: представить имя, вводимое на вход, списком, но тогда пришлось бы отделять буквы имени друг от друга запятыми, что не очень-то и удобно и практично. Вместо этого я реализовала варианты вопросов как на русском, так и на английском языке, получая верные ответы.

Существует много разных диалектов Пролога, некоторые из них очень привлекательны для решения задач грамматического разбора. Вряд ли в императивных языках программирования можно сделать подобное таким элегантным и элементарным способом. Пролог, безусловно, мощный инструмент для грамматического и синтаксического разбора. Он предлагает совершенно иные возможности для написания программ. Из минусов решения подобных задач искусственного интеллекта можно выделить тот факт, что для их решения требуется некоторая база данных, которую приходится писать вручную.
